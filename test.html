<!DOCTYPE html>
<html lang="en">
    <head>
        <title>chimes.club</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <style>
            body {
                font-family: Monospace;
                background-color: #000;
                color: #000;
                margin: 0px;
                overflow: hidden;
            }
            #info {
                text-align: center;
                padding: 10px;
                z-index: 10;
                width: 100%;
                position: absolute;
            }
            a {
                text-decoration: underline;
                cursor: pointer;
            }
        </style>
    </head>

    <body>
        <script src="./node_modules/three/build/three.min.js"></script>
        <script src="./node_modules/cannon/build/cannon.min.js"></script>
        <script src="./node_modules/three/examples/js/controls/TrackballControls.js"></script>
        <!-- <script src="./libs/TrackballControls.js"></script> -->
        <script src="./libs/Detector.js"></script>
        
        <script>

            var MARGIN = 0;
            var SCREEN_WIDTH = window.innerWidth;
            var SCREEN_HEIGHT = window.innerHeight - 2 * MARGIN;
            var NEAR = 5, FAR = 2000;
            var SHADOW_MAP_WIDTH = 1024;
            var SHADOW_MAP_HEIGHT = 1024;

            var scene = new THREE.Scene();

            var dt = 1/60;

            var ballSize = 2;

            var chainCount = 40;
            var chainRadius = 0.5;

            // chime vars
            var chimeCount = 10;
            var chimeLength = 40;
            var chimeRadius = 0.5;
            //var chimeRadius = 2;
            var chimeDistance = 5;

            if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

            var container, stats;
            var camera, scene, renderer;

            // Material
            var materialColor = 0xdddddd;
            var solidMaterial = new THREE.MeshLambertMaterial( { color: materialColor } );

            var sphereMesh, sphereBody;
            var meshes = [];
            var bodies = [];
            var world;

            var cylinderBody, cylinderBody2;

            //init();
            initCannon();
            init();
            animate();

            function initCannon(){
                world = new CANNON.World();
                world.gravity.set(0,0,-40);
                world.broadphase = new CANNON.NaiveBroadphase();
                world.solver.iterations = 10;
                world.quatNormalizeFast = false;
                world.quatNormalizeSkip = 0;

                // create ground
                var groundShape = new CANNON.Plane();
                var groundBody = new CANNON.Body({ mass: 0 });
                groundBody.addShape(groundShape);
                groundBody.position.set(0,0,0);
                world.addBody(groundBody);
                addVisual(groundBody);

                // Create sphere
                var sphereShape = new CANNON.Sphere(ballSize);
                sphereBody = new CANNON.Body({
                    mass: 5
                });
                sphereBody.addShape(sphereShape);
                sphereBody.position.set(0,0,60);
                //bodies.push(sphereBody);
                world.addBody(sphereBody);
                addVisual(sphereBody);

                var sphere2shape = new CANNON.Sphere(ballSize);
                var sphereBody2 = new CANNON.Body({
                    mass: 1
                });
                sphereBody2.addShape(sphere2shape);
                sphereBody2.position.set(1,0,ballSize);
                world.addBody(sphereBody2);
                addVisual(sphereBody2);
            }

            function init() {

                container = document.createElement( 'div' );
                document.body.appendChild( container );

                // scene
                // scene = new THREE.Scene();
                scene.fog = new THREE.Fog( 0x222222, 1000, FAR );

                // AXES
                var axesHelper = new THREE.AxesHelper( 20 );
                scene.add( axesHelper );

                // Camera
                camera = new THREE.PerspectiveCamera( 24, SCREEN_WIDTH / SCREEN_HEIGHT, NEAR, FAR );
                camera.up.set(0,0,1);
                camera.position.set(0,70,10);

                scene.add( camera );

                controls = new THREE.TrackballControls( camera );
                controls.rotateSpeed = 1.0;
                controls.zoomSpeed = 1.2;
                controls.panSpeed = 0.2;
                controls.noZoom = false;
                controls.noPan = false;
                controls.staticMoving = false;
                controls.dynamicDampingFactor = 0.3;
                var radius = 100;
                controls.minDistance = 0.0;
                controls.maxDistance = radius * 1000;
                //controls.keys = [ 65, 83, 68 ]; // [ rotateKey, zoomKey, panKey ]
                controls.screen.width = SCREEN_WIDTH;
                controls.screen.height = SCREEN_HEIGHT;

                // lights
                var light, materials;
                scene.add( new THREE.AmbientLight( 0x666666 ) );

                light = new THREE.DirectionalLight( 0xffffff, 1.75 );
                var d = 5;

                light.position.set( d, d, d );
                light.castShadow = true;

                light = new THREE.SpotLight( 0xffffff );
                light.position.set( 30, 30, 40 );
                light.target.position.set( 0, 0, 0 );
                light.castShadow = true;
                light.shadowCameraNear = 10;
                light.shadowCameraFar = 100;//camera.far;
                light.shadowCameraFov = 30;
                light.shadowMapBias = 0.0039;
                light.shadowMapDarkness = 0.5;
                light.shadowMapWidth = SHADOW_MAP_WIDTH;
                light.shadowMapHeight = SHADOW_MAP_HEIGHT;
                scene.add( light );

                ambient = new THREE.AmbientLight( 0x222222 );
                scene.add( ambient );

                // renderer
                renderer = new THREE.WebGLRenderer( { antialias: true } );
                renderer.setSize( window.innerWidth, window.innerHeight );
                renderer.setClearColor( scene.fog.color );

                container.appendChild( renderer.domElement );

                renderer.gammaInput = true;
                renderer.gammaOutput = true;
                renderer.physicallyBasedShading = true;
                renderer.shadowMap.enabled = true;

                window.addEventListener( 'resize', onWindowResize, false );

                // sphere
                /*
                var ballGeo = new THREE.SphereGeometry( ballSize, 20, 20 );
                var ballMaterial = new THREE.MeshPhongMaterial( { color: 0x888888 } );

                sphereMesh = new THREE.Mesh( ballGeo, ballMaterial );
                sphereMesh.castShadow = true;
                sphereMesh.receiveShadow = true;
                meshes.push(sphereMesh);
                scene.add( sphereMesh );
                */

                // ground
                /*
                var geometry = new THREE.PlaneGeometry( 100, 100 );
                var material = new THREE.MeshPhongMaterial( { color: 0x888888 } );
                var plane = new THREE.Mesh( geometry, material );
                plane.castShadow = true;
                plane.receiveShadow = true;
                scene.add( plane );
                */

                // test cylinder
                /*
                var geometry = new THREE.CylinderGeometry( chimeRadius, chimeRadius, chimeLength, 32 );
                var material = new THREE.MeshPhongMaterial( {color: 0xffff00} );
                var cylinder = new THREE.Mesh( geometry, material );
                cylinder.castShadow = true;
                cylinder.receiveShadow = true;
                meshes.push(cylinder);
                scene.add( cylinder );
                */

                // geometry = new THREE.CylinderGeometry( chimeRadius, chimeRadius, chimeLength, 32 );
                // material = new THREE.MeshPhongMaterial( {color: 0xffff00} );
                // var cylinder2 = new THREE.Mesh( geometry, material );
                // cylinder.castShadow = true;
                // cylinder.receiveShadow = true;
                // meshes.push(cylinder2);
                // scene.add( cylinder2 );

                // point camera
                //camera.lookAt( sphereMesh.position );
            }

            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                controls.handleResize();
                renderer.setSize( window.innerWidth, window.innerHeight );
            }

            function animate() {
                requestAnimationFrame( animate );
                controls.update();
                world.step(dt);
                render();
            }

            function render() {
                //sphereMesh.position.copy(sphereBody.position);
                //sphereMesh.position.copy(sphereBody.position);
                
                for(var i = 0; i < meshes.length; i++) {
                    meshes[i].position.copy(bodies[i].position);
                }
                renderer.render( scene, camera );
            }

            function addVisual(body){
                var s = this.settings;
                // What geometry should be used?
                var mesh;
                if(body instanceof CANNON.Body){
                    mesh = shape2mesh(body);
                }
                if(mesh) {
                    // Add body
                    //this.bodies.push(body);
                    //this.visuals.push(mesh);
                    bodies.push(body);
                    meshes.push(mesh);
                    body.visualref = mesh;
                    body.visualref.visualId = bodies.length - 1;
                    //mesh.useQuaternion = true;
                    scene.add(mesh);
                }
            };

            function shape2mesh(body) {
                //var wireframe = this.settings.renderMode === "wireframe";
                var obj = new THREE.Object3D();

                for (var l = 0; l < body.shapes.length; l++) {
                    var shape = body.shapes[l];

                    var mesh;

                    switch(shape.type){

                    case CANNON.Shape.types.SPHERE:
                        console.log("sphere!!")
                        var sphere_geometry = new THREE.SphereGeometry( shape.radius, 16, 16);
                        mesh = new THREE.Mesh( sphere_geometry, solidMaterial );
                        break;

                    case CANNON.Shape.types.PARTICLE:
                        mesh = new THREE.Mesh( this.particleGeo, this.particleMaterial );
                        var s = this.settings;
                        mesh.scale.set(s.particleSize,s.particleSize,s.particleSize);
                        break;

                    case CANNON.Shape.types.PLANE:
                        var geometry = new THREE.PlaneGeometry(10, 10, 4, 4);
                        mesh = new THREE.Object3D();
                        var submesh = new THREE.Object3D();
                        var ground = new THREE.Mesh( geometry, solidMaterial );
                        ground.scale.set(100, 100, 100);
                        submesh.add(ground);

                        ground.castShadow = true;
                        ground.receiveShadow = true;

                        mesh.add(submesh);
                        break;

                    case CANNON.Shape.types.BOX:
                        var box_geometry = new THREE.BoxGeometry(  shape.halfExtents.x*2,
                                                                    shape.halfExtents.y*2,
                                                                    shape.halfExtents.z*2 );
                        mesh = new THREE.Mesh( box_geometry, solidMaterial );
                        break;

                    case CANNON.Shape.types.CONVEXPOLYHEDRON:

                    console.log("CONVEX POLY")
                        var geo = new THREE.Geometry();

                        // Add vertices
                        for (var i = 0; i < shape.vertices.length; i++) {
                            var v = shape.vertices[i];
                            geo.vertices.push(new THREE.Vector3(v.x, v.y, v.z));
                        }

                        for(var i=0; i < shape.faces.length; i++){
                            var face = shape.faces[i];

                            // add triangles
                            var a = face[0];
                            for (var j = 1; j < face.length - 1; j++) {
                                var b = face[j];
                                var c = face[j + 1];
                                geo.faces.push(new THREE.Face3(a, b, c));
                            }
                        }
                        geo.computeBoundingSphere();
                        geo.computeFaceNormals();
                        mesh = new THREE.Mesh( geo, solidMaterial );
                        break;

                    case CANNON.Shape.types.HEIGHTFIELD:
                        var geometry = new THREE.Geometry();

                        var v0 = new CANNON.Vec3();
                        var v1 = new CANNON.Vec3();
                        var v2 = new CANNON.Vec3();
                        for (var xi = 0; xi < shape.data.length - 1; xi++) {
                            for (var yi = 0; yi < shape.data[xi].length - 1; yi++) {
                                for (var k = 0; k < 2; k++) {
                                    shape.getConvexTrianglePillar(xi, yi, k===0);
                                    v0.copy(shape.pillarConvex.vertices[0]);
                                    v1.copy(shape.pillarConvex.vertices[1]);
                                    v2.copy(shape.pillarConvex.vertices[2]);
                                    v0.vadd(shape.pillarOffset, v0);
                                    v1.vadd(shape.pillarOffset, v1);
                                    v2.vadd(shape.pillarOffset, v2);
                                    geometry.vertices.push(
                                        new THREE.Vector3(v0.x, v0.y, v0.z),
                                        new THREE.Vector3(v1.x, v1.y, v1.z),
                                        new THREE.Vector3(v2.x, v2.y, v2.z)
                                    );
                                    var i = geometry.vertices.length - 3;
                                    geometry.faces.push(new THREE.Face3(i, i+1, i+2));
                                }
                            }
                        }
                        geometry.computeBoundingSphere();
                        geometry.computeFaceNormals();
                        mesh = new THREE.Mesh(geometry, solidMaterial);
                        break;

                    case CANNON.Shape.types.TRIMESH:
                        var geometry = new THREE.Geometry();

                        var v0 = new CANNON.Vec3();
                        var v1 = new CANNON.Vec3();
                        var v2 = new CANNON.Vec3();
                        for (var i = 0; i < shape.indices.length / 3; i++) {
                            shape.getTriangleVertices(i, v0, v1, v2);
                            geometry.vertices.push(
                                new THREE.Vector3(v0.x, v0.y, v0.z),
                                new THREE.Vector3(v1.x, v1.y, v1.z),
                                new THREE.Vector3(v2.x, v2.y, v2.z)
                            );
                            var j = geometry.vertices.length - 3;
                            geometry.faces.push(new THREE.Face3(j, j+1, j+2));
                        }
                        geometry.computeBoundingSphere();
                        geometry.computeFaceNormals();
                        mesh = new THREE.Mesh(geometry, solidMaterial);
                        break;

                    default:
                        throw "Visual type not recognized: "+shape.type;
                    }

                    mesh.receiveShadow = true;
                    mesh.castShadow = true;
                    if(mesh.children){
                        for(var i=0; i<mesh.children.length; i++){
                            mesh.children[i].castShadow = true;
                            mesh.children[i].receiveShadow = true;
                            if(mesh.children[i]){
                                for(var j=0; j<mesh.children[i].length; j++){
                                    mesh.children[i].children[j].castShadow = true;
                                    mesh.children[i].children[j].receiveShadow = true;
                                }
                            }
                        }
                    }

                    var o = body.shapeOffsets[l];
                    var q = body.shapeOrientations[l];
                    mesh.position.set(o.x, o.y, o.z);
                    mesh.quaternion.set(q.x, q.y, q.z, q.w);

                    obj.add(mesh);
                }

                return obj;
            };

        </script>
    </body>
</html>

<!DOCTYPE html>
<html lang="en">
    <head>
        <title>chimes.club</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <style>
            body {
                font-family: Monospace;
                background-color: #000;
                color: #000;
                margin: 0px;
                overflow: hidden;
            }
            #info {
                text-align: center;
                padding: 10px;
                z-index: 10;
                width: 100%;
                position: absolute;
            }
            a {
                text-decoration: underline;
                cursor: pointer;
            }
        </style>
    </head>

    <body>
        <script src="./node_modules/three/build/three.min.js"></script>
        <script src="./node_modules/cannon/build/cannon.min.js"></script>
        <script src="./node_modules/web-audio-daw/build/wad.min.js"></script>
        <script src="./node_modules/lodash/lodash.min.js"></script>
        <script src="./node_modules/three/examples/js/controls/TrackballControls.js"></script>
        <script src="./libs/Detector.js"></script>
        
        <script>

            var MARGIN = 0;
            var SCREEN_WIDTH = window.innerWidth;
            var SCREEN_HEIGHT = window.innerHeight - 2 * MARGIN;
            var NEAR = 5, FAR = 2000;
            // var SHADOW_MAP_WIDTH = 2048; //1024;
            // var SHADOW_MAP_HEIGHT = 2048; //1024;
            var SHADOW_MAP_WIDTH = 1024;
            var SHADOW_MAP_HEIGHT = 1024;

            // shape constants
            var CHIME_TYPE = "chime";
            var STRIKER_TYPE = "striker";
            var CHAIN_TYPE = "chain";

            if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

            var container;
            var camera, scene, renderer;

            var scene = new THREE.Scene();

            var dt = 1/60;

            // wad vars
            var sine;
            var hiss;
            var chimeSounds = {}; // map of chime body index -> note

            // html
            var info;

            // chain vars
            var chainCount = 20;
            var chainRadius = 0.5;
            var chainMass = 1;

            // striker vars // height above origin = 7 ->
            var strikerMass = 10;
            var strikerTopRadius = 1;
            var strikerTopLength = 10;
            var strikerBottomRadius = 5;
            var strikerBottomLength = 2;
            var strikerTotalLength = strikerTopLength + strikerBottomLength;
            var strikerIndex; // the index of the striker in the bodies array
            var strikerBody = new CANNON.Body({ mass: strikerMass });

            // chime vars
            var chimeCount = 5;
            var chimeLength = 40; // height above origin = 20
            var chimeRadius = 1.5;//0.5;
            var chimeDistance = 9;
            var chimeMass = 5;
            var chimeShape = new CANNON.Cylinder(chimeRadius,chimeRadius,chimeLength,40);
            var chimeLights = {};
            var chimeLight;

            // second tier chimes
            var secondTierChimeCount = 7;

            // shared material
            //var materialColor = 0xdddddd;
            var materialColor = 0x888888;
            var solidMaterial = new THREE.MeshPhongMaterial({ 
                color: materialColor, 
                specular: 0x050505,
                shininess: 100 }
            );

            var meshes = [];
            var bodies = [];
            var chimeIndices = []; // indices of chimes in bodies array
            var world;

            // last played frame cache
            // need to add collisions between each object, not just all collisions in general. collisions between separately.
            var lastPlayedFrames = {};
            var frameSensitivity = 90;

            initCannon();
            initThree();
            initWad();
            animate();

            console.log(chimeLights);

            function initCannon(){
                world = new CANNON.World();
                world.gravity.set(0,0,-40);
                world.broadphase = new CANNON.NaiveBroadphase();
                world.solver.iterations = 20;
                world.quatNormalizeFast = false;
                world.quatNormalizeSkip = 0;

                // set up top
                var topShape = new CANNON.Cylinder(chimeDistance+1,chimeDistance+1,0.5,40);
                var topBody = new CANNON.Body({ mass: 0 });
                topBody.addShape(topShape);
                topBody.position.set(0,0,(chimeLength/2) + chainCount + chainRadius)
                world.addBody(topBody);
                bodies.push(topBody);
                addVisual(topBody);

                // set up striker
                strikerBody.position.set(0,0,-5); // why is it off by 5?
                var strikerTopShape = new CANNON.Cylinder(strikerTopRadius,strikerTopRadius,strikerTopLength,40);
                var strikerBottomShape = new CANNON.Cylinder(strikerBottomRadius,strikerBottomRadius,strikerBottomLength,40);
                strikerBody.addShape(strikerTopShape, new CANNON.Vec3( 0, 0, (strikerTopLength/2) + (strikerBottomLength/2)));
                strikerBody.addShape(strikerBottomShape, new CANNON.Vec3(0,0,0));
                world.addBody(strikerBody);
                bodies.push(strikerBody);
                
                strikerIndex = bodies.length-1;
                console.log("INDEX: " + strikerIndex);
                addVisual(strikerBody);

                // set up striker chain
                var strikerChainCount = chainCount + (chimeLength/2) - (strikerTotalLength/2);
                var lastChainBody = null;
                for(var j=0; j<strikerChainCount; j++) {
                    var chainShape = new CANNON.Sphere(chainRadius);
                    var chainBody = new CANNON.Body({ mass: chainMass });
                    chainBody.addShape(chainShape);
                    chainBody.linearDamping=0.01; // Damping makes the movement slow down with time
                    chainBody.angularDamping=0.01;
                    chainBody.position.set(0, 0, (strikerTotalLength/2)+chainRadius+j);
                    world.addBody(chainBody);
                    bodies.push(chainBody);
                    addVisual(chainBody);
                    
                    // for first chain link, attach striker
                    if(j == 0) {
                        var strikerChainDistance = (strikerTotalLength/2)+chainRadius+5;
                        var cc = new CANNON.PointToPointConstraint(strikerBody,new CANNON.Vec3(0,0,(strikerTotalLength/2)+chainRadius+5),chainBody,new CANNON.Vec3(0,0,0)); // off by 5 again
                        world.addConstraint(cc);
                    }
                    // for last, attach to top and previous -- this can be made more efficient. repeated code
                    else if(j == strikerChainCount-1) {
                        var tc = new CANNON.PointToPointConstraint(chainBody,new CANNON.Vec3(0,0,1),topBody,new CANNON.Vec3(0,0,0));
                        var lc = new CANNON.PointToPointConstraint(lastChainBody,new CANNON.Vec3(0,0,1),chainBody,new CANNON.Vec3(0,0,0));
                        world.addConstraint(lc);
                        world.addConstraint(tc);
                    }
                    // for others, attach to each other
                    else {
                        var lc = new CANNON.PointToPointConstraint(lastChainBody,new CANNON.Vec3(0,0,1),chainBody,new CANNON.Vec3(0,0,0));
                        world.addConstraint(lc);
                    }

                    // set last link to current link
                    lastChainBody = chainBody;

                }

                // create chimes
                //world.solver.iterations = chainCount + chainCount; // To be able to propagate force throw the chain of N spheres, we need at least N solver iterations.
                for(var i=0; i<chimeCount; i++){
                    
                    // create chime
                    var chimeBody = new CANNON.Body({ mass: chimeMass });
                    chimeBody.addShape(chimeShape);
                    chimeBody.linearDamping=0.01; // Damping makes the movement slow down with time
                    chimeBody.angularDamping=0.01;
                    
                    var xChimePos = chimeDistance*Math.sin( (i/chimeCount) * (2*Math.PI) );
                    var yChimePos = chimeDistance*Math.cos( (i/chimeCount) * (2*Math.PI) );
                    var zChimePos = 0;
                    
                    chimeBody.position.set(xChimePos, yChimePos, zChimePos)
                    world.addBody(chimeBody);
                    bodies.push(chimeBody);
                    chimeIndices.push(bodies.length-1); // track index of chime in bodies array
                    addVisual(chimeBody, CHIME_TYPE);

                    var lastChainBody = null;
                    for(var j=0; j<chainCount; j++) {
                        var chainShape = new CANNON.Sphere(chainRadius);
                        var chainBody = new CANNON.Body({ mass: 1 });
                        chainBody.addShape(chainShape);
                        chainBody.linearDamping=0.01; // Damping makes the movement slow down with time
                        chainBody.angularDamping=0.01;
                        chainBody.position.set(xChimePos, yChimePos, (chimeLength/2)+chainRadius+j);
                        world.addBody(chainBody);
                        bodies.push(chainBody);
                        addVisual(chainBody);
                        
                        // for first chain link, attach chime
                        if(j == 0) {
                            var cc = new CANNON.PointToPointConstraint(chimeBody,new CANNON.Vec3(0,0,(chimeLength/2)+chainRadius),chainBody,new CANNON.Vec3(0,0,0));
                            world.addConstraint(cc);
                        }
                        // for last, attach to top and previous -- this can be made more efficient. repeated code
                        else if(j == chainCount-1) {
                            var tc = new CANNON.PointToPointConstraint(chainBody,new CANNON.Vec3(0,0,1),topBody,new CANNON.Vec3(xChimePos,yChimePos,0));
                            var lc = new CANNON.PointToPointConstraint(lastChainBody,new CANNON.Vec3(0,0,1),chainBody,new CANNON.Vec3(0,0,0));
                            world.addConstraint(lc);
                            world.addConstraint(tc);
                        }
                        // for others, attach to each other
                        else {
                            var lc = new CANNON.PointToPointConstraint(lastChainBody,new CANNON.Vec3(0,0,1),chainBody,new CANNON.Vec3(0,0,0));
                            world.addConstraint(lc);
                        }

                        // set last link to current link
                        lastChainBody = chainBody;
                    }

                }

                /*
                // second tier chimes
                var secondTierChimeShape = new CANNON.Cylinder(chimeRadius,chimeRadius,30,40);
                for(var i=0; i<secondTierChimeCount; i++){
                    
                    // create chime
                    var chimeBody = new CANNON.Body({ mass: chimeMass });
                    chimeBody.addShape(secondTierChimeShape);
                    chimeBody.linearDamping=0.01; // Damping makes the movement slow down with time
                    chimeBody.angularDamping=0.01;
                    
                    var xChimePos = (9+chimeDistance)*Math.sin( (i/secondTierChimeCount) * (2*Math.PI) );
                    var yChimePos = (9+chimeDistance)*Math.cos( (i/secondTierChimeCount) * (2*Math.PI) );
                    var zChimePos = 5;
                    
                    chimeBody.position.set(xChimePos, yChimePos, zChimePos)
                    world.addBody(chimeBody);
                    bodies.push(chimeBody);
                    chimeIndices.push(bodies.length-1); // track index of chime in bodies array
                    addVisual(chimeBody, CHIME_TYPE);

                    var lastChainBody = null;
                    for(var j=0; j<chainCount; j++) {
                        var chainShape = new CANNON.Sphere(chainRadius);
                        var chainBody = new CANNON.Body({ mass: 1 });
                        chainBody.addShape(chainShape);
                        chainBody.linearDamping=0.01; // Damping makes the movement slow down with time
                        chainBody.angularDamping=0.01;
                        chainBody.position.set(xChimePos, yChimePos, (chimeLength/2)+chainRadius+j);
                        world.addBody(chainBody);
                        bodies.push(chainBody);
                        addVisual(chainBody);
                        
                        // for first chain link, attach chime
                        if(j == 0) {
                            var cc = new CANNON.PointToPointConstraint(chimeBody,new CANNON.Vec3(0,0,((chimeLength-10)/2)+chainRadius),chainBody,new CANNON.Vec3(0,0,0));
                            world.addConstraint(cc);
                        }
                        // for last, attach to top and previous -- this can be made more efficient. repeated code
                        else if(j == chainCount-1) {
                            var tc = new CANNON.PointToPointConstraint(chainBody,new CANNON.Vec3(0,0,1),topBody,new CANNON.Vec3(xChimePos,yChimePos,0));
                            var lc = new CANNON.PointToPointConstraint(lastChainBody,new CANNON.Vec3(0,0,1),chainBody,new CANNON.Vec3(0,0,0));
                            world.addConstraint(lc);
                            world.addConstraint(tc);
                        }
                        // for others, attach to each other
                        else {
                            var lc = new CANNON.PointToPointConstraint(lastChainBody,new CANNON.Vec3(0,0,1),chainBody,new CANNON.Vec3(0,0,0));
                            world.addConstraint(lc);
                        }

                        // set last link to current link
                        lastChainBody = chainBody;
                    }

                }
                */

            }

            function initThree() {

                container = document.createElement( 'div' );
                document.body.appendChild( container );

                // scene
                // scene.fog = new THREE.Fog( 0x222222, 1000, FAR );
                scene.fog = new THREE.Fog( 0x000000, 1000, FAR );

                // camera
                camera = new THREE.PerspectiveCamera( 24, SCREEN_WIDTH / SCREEN_HEIGHT, NEAR, FAR );
                camera.up.set(0,0,1);
                camera.position.set(0,150,20);

                scene.add( camera );

                controls = new THREE.TrackballControls( camera );
                controls.rotateSpeed = 1.3;
                controls.zoomSpeed = 1.2;
                controls.panSpeed = 0.2;
                controls.noZoom = false;
                controls.noPan = false;
                controls.staticMoving = false;
                controls.dynamicDampingFactor = 0.1;
                var radius = 100;
                controls.minDistance = 0.0;
                controls.maxDistance = radius * 1000;
                controls.screen.width = SCREEN_WIDTH;
                controls.screen.height = SCREEN_HEIGHT;

                // lights
                var light, ambient;
                //ambient = new THREE.AmbientLight( 0x222222 );
                ambient = new THREE.AmbientLight( 0x000000 );
                scene.add( ambient );

                //light = new THREE.SpotLight( 0xffffff );
                light = new THREE.SpotLight( 0xffffff );
                light.position.set( 30, 30, 40 );
                light.target.position.set( 0, 0, 0 );

                light.castShadow = true;

                light.shadow.camera.near = 10;
                light.shadow.camera.far = 100;//camera.far;
                light.shadow.camera.fov = 30;

                light.shadowMapBias = 0.0039;
                light.shadowMapDarkness = 0.5;
                light.shadow.mapSize.width = SHADOW_MAP_WIDTH;
                light.shadow.mapSize.height = SHADOW_MAP_HEIGHT;
                scene.add(light);

                // renderer
                //renderer = new THREE.WebGLRenderer( { antialias: true } );
                renderer = new THREE.WebGLRenderer( { antialias: true, maxLights: 20 } );
                renderer.setSize( window.innerWidth, window.innerHeight );
                renderer.setClearColor( scene.fog.color );

                container.appendChild( renderer.domElement );

                renderer.gammaInput = true;
                renderer.gammaOutput = true;
                renderer.physicallyBasedShading = true;
                renderer.shadowMap.enabled = true;

                window.addEventListener( 'resize', onWindowResize, false );

                // Add info
                info = document.createElement( 'div' );
                info.style.position = 'absolute';
                info.style.top = '15px';
                info.style.width = '100%';
                info.style.textAlign = 'center';
                info.style.color = 'white';
                info.innerHTML = 'chimes.club';
                container.appendChild( info );

            }

            function initWad() {
                // set up chime sounds
                chimeSounds[chimeIndices[0]] = 'A4';
                chimeSounds[chimeIndices[1]] = 'C4';
                chimeSounds[chimeIndices[2]] = 'E4';
                chimeSounds[chimeIndices[3]] = 'G4';
                chimeSounds[chimeIndices[4]] = 'C5';
                chimeSounds[chimeIndices[5]] = 'D5';
                chimeSounds[chimeIndices[6]] = 'E5';

                // initialize lastPlayedFrames to 0 for each chime
                for(var i=0; i<=chimeIndices.length; i++) {
                    // add the striker body index
                    if(i==chimeIndices.length) {
                        lastPlayedFrames[strikerIndex] = {};
                        for(var j=0; j<chimeIndices.length; j++) {
                            lastPlayedFrames[strikerIndex][chimeIndices[j]] = 0;
                        }
                        lastPlayedFrames[strikerIndex][strikerIndex] = 0;
                    }
                    else {
                        lastPlayedFrames[chimeIndices[i]] = {};
                        for(var j=0; j<chimeIndices.length; j++) {
                            lastPlayedFrames[chimeIndices[i]][chimeIndices[j]] = 0;
                        }
                        // add striker body to each chime row
                        for(var j=0; j<=chimeIndices.length; j++) {
                            lastPlayedFrames[chimeIndices[i]][strikerIndex] = 0;
                        }
                    }
                }

                hiss = new Wad({
                    source : './audio/tapenoise.wav',
                    volume: 1.3,
                    rate: 0.5,
                    loop: true,
                    env     : {      // This is the ADSR envelope.
                        attack  : 1.0,  // Time in seconds from onset to peak volume.  Common values for oscillators may range from 0.05 to 0.3.
                        decay   : 0.0,  // Time in seconds from peak volume to sustain volume.
                        sustain : 1.0,  // Sustain volume level. This is a percent of the peak volume, so sensible values are between 0 and 1.
                        hold    : 10000.0, // Time in seconds to maintain the sustain volume level. If this is not set to a lower value, oscillators must be manually stopped by calling their stop() method.
                        release : 0     // Time in seconds from the end of the hold period to zero volume, or from calling stop() to zero volume.
                    },
                    filter  : {
                        frequency : 2000,
                        q         : 3,
                    },
                    // reverb  : {
                    //     wet     : 1,                                            // Volume of the reverberations.
                    //     impulse : './node_modules/tunajs/impulses/impulse_rev.wav' // A URL for an impulse response file, if you do not want to use the default impulse response.
                    // },
                    delay   : {
                        delayTime : .5,  // Time in seconds between each delayed playback.
                        wet       : .3, // Relative volume change between the original sound and the first delayed playback.
                        feedback  : .4, // Relative volume change between each delayed playback and the next. 
                    }
                });
                hiss.play();

                sine = new Wad({
                    source  : 'sine',
                    volume  : 0.2,   // Peak volume can range from 0 to an arbitrarily high number, but you probably shouldn't set it higher than 1.
                    loop    : false, // If true, the audio will loop. This parameter only works for audio clips, and does nothing for oscillators. 
                    rate    : 1.0, // How fast to play an audio clip, relative to its normal speed. 2.0 is double speed, 0.5 is half speed, etc.
                    offset  : 0,     // Where in the audio clip playback begins, measured in seconds from the start of the audio clip.
                    detune  : 0,     // Set a default detune on the constructor if you don't want to set detune on <code>play()</code>. Detune is measured in cents. 100 cents is equal to 1 semitone.
                    panning : 0,   // Horizontal placement of the sound source. Possible values are from 1 to -1.
                    env     : {      // This is the ADSR envelope.
                        attack  : 0.1,  // Time in seconds from onset to peak volume.  Common values for oscillators may range from 0.05 to 0.3.
                        decay   : 0.5,  // Time in seconds from peak volume to sustain volume.
                        sustain : 0.0,  // Sustain volume level. This is a percent of the peak volume, so sensible values are between 0 and 1.
                        hold    : 0.0, // Time in seconds to maintain the sustain volume level. If this is not set to a lower value, oscillators must be manually stopped by calling their stop() method.
                        release : 0.0     // Time in seconds from the end of the hold period to zero volume, or from calling stop() to zero volume.
                    },
                    // reverb  : {
                    //     wet     : 1,                                            // Volume of the reverberations.
                    //     impulse : './node_modules/tunajs/impulses/Sweetspot1M.wav' // A URL for an impulse response file, if you do not want to use the default impulse response.
                    // },
                    delay   : {
                        delayTime : .5,  // Time in seconds between each delayed playback.
                        wet       : .3, // Relative volume change between the original sound and the first delayed playback.
                        feedback  : .4, // Relative volume change between each delayed playback and the next. 
                    },
                });
            }

            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                controls.handleResize();
                renderer.setSize( window.innerWidth, window.innerHeight );
            }

            var frame = 0;
            function animate() {
                checkBodyContacts(frame);
                // give the chimes a push every 10(?) secs
                if(frame % 1200 == 0) {
                    var xDir = 1;
                    var yDir = 1;
                    if(Math.random() > 0.5) {
                        xDir = -1;
                    }
                    if(Math.random() > 0.5) {
                        yDir = -1;
                    }
                    strikerBody.velocity.x = xDir * 30 * Math.random(); 
                    strikerBody.velocity.y = yDir * 30 * Math.random();
                    
                    for(var i=0; i<chimeIndices.length; i++) {
                        var chimeBody = bodies[chimeIndices[i]];
                        chimeBody.velocity.x = xDir * 20 * Math.random(); 
                        chimeBody.velocity.y = yDir * 20 * Math.random();
                    }
                }
                // prevent overflow?
                if(frame % 12000000 == 0) {
                    frame = 0;
                }

                requestAnimationFrame( animate );
                controls.update();
                world.step(dt);
                render();
                frame++;
            }

            function render() {
                // mesh index must match body index            
                for(var i = 0; i < meshes.length; i++) {
                    meshes[i].position.copy(bodies[i].position);
                    meshes[i].quaternion.copy(bodies[i].quaternion)
                }
                renderer.render( scene, camera );
            }

            function checkBodyContacts(frame){
                // reset colors of chimes
                for(var j=0; j<bodies.length; j++) {
                    if(chimeIndices.includes(j)) {
                        meshes[j].children[0].material.color.r = 0.1;
                        meshes[j].children[0].material.color.g = 0.1;
                        meshes[j].children[0].material.color.b = 0.1;
                        chimeLights[j].power = 0;
                    }
                }
                
                // reverse these for loops?
                var collidingBodies = bodies.slice();
                for(var i=0; i<world.contacts.length; i++){
                    var c = world.contacts[i];
                    for(var j=0; j<bodies.length; j++) {
                        if(c.bi === bodies[j] || c.bj === bodies[j]) {
                            // if colliding and a chime, color red
                            if(chimeIndices.includes(j)) {
                                meshes[j].children[0].material.color.r = 1;
                                meshes[j].children[0].material.color.g = 0;
                                meshes[j].children[0].material.color.b = 0;
                                chimeLights[j].power = 5;
                            }
                        }
                    }

                    for(var k=0; k<chimeIndices.length; k++) {
                        var chimeIndex = chimeIndices[k];
                        // if body is a chime
                        if(c.bi === bodies[chimeIndex] || c.bj === bodies[chimeIndex]){
                            // if sound has not played in last -frameSensitivity- frames, then play sound
                            if(frame - lastPlayedFrames[chimeIndex] > frameSensitivity) {
                                playSine({'pitch': chimeSounds[chimeIndex]});
                                lastPlayedFrames[chimeIndex] = frame;
                            }
                        }
                        
                        // if first body is chime
                        if(c.bi === bodies[chimeIndex]){
                            // if second body is striker
                            if(c.bj === bodies[strikerIndex]) {
                                if(frame - lastPlayedFrames[chimeIndex][strikerIndex] > frameSensitivity) {
                                    playSine({'pitch': chimeSounds[chimeIndex]});
                                    lastPlayedFrames[chimeIndex][strikerIndex] = frame;
                                }
                            }
                            else {
                                for(var l=0; l<chimeIndices.length; l++) {
                                    var chimeIndex2 = chimeIndices[l];
                                    // if second body is different chime
                                    if(chimeIndex2 != chimeIndex && c.bj === bodies[chimeIndex2]) {
                                        // if sound has not played in last -frameSensitivity- frames, then play sound
                                        if(frame - lastPlayedFrames[chimeIndex][chimeIndex2] > frameSensitivity) {
                                            playSine({'pitch': chimeSounds[chimeIndex]});
                                            lastPlayedFrames[chimeIndex][chimeIndex2] = frame;
                                        }
                                    }                                
                                }
                            }
                        }
                        // if second body is chime
                        else if(c.bj === bodies[chimeIndex]){
                            // if first body is striker
                            if(c.bi === bodies[strikerIndex]) {
                                if(frame - lastPlayedFrames[strikerIndex][chimeIndex] > frameSensitivity) {
                                    playSine({'pitch': chimeSounds[chimeIndex]});
                                    lastPlayedFrames[strikerIndex][chimeIndex] = frame;
                                }
                            }
                            else {
                                for(var l=0; l<chimeIndices.length; l++) {
                                    var chimeIndex2 = chimeIndices[l];
                                    // if first body is different chime
                                    if(chimeIndex2 != chimeIndex && c.bi === bodies[chimeIndex2]) {
                                        // if sound has not played in last -frameSensitivity- frames, then play sound
                                        if(frame - lastPlayedFrames[chimeIndex2][chimeIndex] > frameSensitivity) {
                                            playSine({'pitch': chimeSounds[chimeIndex]});
                                            lastPlayedFrames[chimeIndex2][chimeIndex] = frame;
                                        }
                                    }
                                }
                            }
                        }
                    }
                        
                }

            }

            function addVisual(body, type){
                var s = this.settings;
                // What geometry should be used?
                var mesh;
                if(body instanceof CANNON.Body){
                    mesh = shape2mesh(body, type);
                }
                if(mesh) {
                    // add mesh
                    meshes.push(mesh);
                    body.visualref = mesh;
                    body.visualref.visualId = bodies.length - 1;
                    //mesh.useQuaternion = true;
                    scene.add(mesh);
                    
                    // add lights to chimes
                    if(type == CHIME_TYPE) {
                        var chimeLight = new THREE.PointLight( 0xff0000, 2, 50 );
                        chimeLight.add( mesh );
                        scene.add( chimeLight );
                        chimeLight.power = 0;
                        chimeLights[meshes.length-1] = chimeLight;
                    }
                }
            };

            function shape2mesh(body, type) {
                var obj = new THREE.Object3D();

                for (var l = 0; l < body.shapes.length; l++) {
                    var shape = body.shapes[l];

                    var mesh;

                    switch(shape.type){

                    case CANNON.Shape.types.SPHERE:
                        var sphere_geometry = new THREE.SphereGeometry( shape.radius, 16, 16);
                        mesh = new THREE.Mesh( sphere_geometry, solidMaterial );
                        break;

                    case CANNON.Shape.types.PARTICLE:
                        mesh = new THREE.Mesh( this.particleGeo, this.particleMaterial );
                        var s = this.settings;
                        mesh.scale.set(s.particleSize,s.particleSize,s.particleSize);
                        break;

                    case CANNON.Shape.types.PLANE:
                        var geometry = new THREE.PlaneGeometry(10, 10, 4, 4);
                        mesh = new THREE.Object3D();
                        var submesh = new THREE.Object3D();
                        var ground = new THREE.Mesh( geometry, solidMaterial );
                        ground.scale.set(100, 100, 100);
                        submesh.add(ground);

                        ground.castShadow = true;
                        ground.receiveShadow = true;

                        mesh.add(submesh);
                        break;

                    case CANNON.Shape.types.BOX:
                        var box_geometry = new THREE.BoxGeometry(  shape.halfExtents.x*2,
                                                                    shape.halfExtents.y*2,
                                                                    shape.halfExtents.z*2 );
                        mesh = new THREE.Mesh( box_geometry, solidMaterial );
                        break;

                    case CANNON.Shape.types.CONVEXPOLYHEDRON:

                        var geo = new THREE.Geometry();

                        // Add vertices
                        for (var i = 0; i < shape.vertices.length; i++) {
                            var v = shape.vertices[i];
                            geo.vertices.push(new THREE.Vector3(v.x, v.y, v.z));
                        }

                        for(var i=0; i < shape.faces.length; i++){
                            var face = shape.faces[i];

                            // add triangles
                            var a = face[0];
                            for (var j = 1; j < face.length - 1; j++) {
                                var b = face[j];
                                var c = face[j + 1];
                                geo.faces.push(new THREE.Face3(a, b, c));
                            }
                        }
                        geo.computeBoundingSphere();
                        geo.computeFaceNormals();
                        
                        var currentMaterial;
                        var mesh;
                        if(type == CHIME_TYPE) {
                            // for each chime, separate material
                            currentMaterial = new THREE.MeshPhongMaterial({ 
                                color: materialColor,
                                specular: 0x050505,
                                shininess: 100} 
                            );
                            mesh = new THREE.Mesh( geo, currentMaterial );
                        }
                        else {
                            currentMaterial = solidMaterial;
                            mesh = new THREE.Mesh( geo, currentMaterial );

                            var strikerLight = new THREE.PointLight( 0x80ff80, 2, 50 );
                            strikerLight.add( mesh );
                            scene.add( strikerLight );
                            strikerLight.power = 0;
                        }
                        
                        
                        break;

                    case CANNON.Shape.types.HEIGHTFIELD:
                        var geometry = new THREE.Geometry();

                        var v0 = new CANNON.Vec3();
                        var v1 = new CANNON.Vec3();
                        var v2 = new CANNON.Vec3();
                        for (var xi = 0; xi < shape.data.length - 1; xi++) {
                            for (var yi = 0; yi < shape.data[xi].length - 1; yi++) {
                                for (var k = 0; k < 2; k++) {
                                    shape.getConvexTrianglePillar(xi, yi, k===0);
                                    v0.copy(shape.pillarConvex.vertices[0]);
                                    v1.copy(shape.pillarConvex.vertices[1]);
                                    v2.copy(shape.pillarConvex.vertices[2]);
                                    v0.vadd(shape.pillarOffset, v0);
                                    v1.vadd(shape.pillarOffset, v1);
                                    v2.vadd(shape.pillarOffset, v2);
                                    geometry.vertices.push(
                                        new THREE.Vector3(v0.x, v0.y, v0.z),
                                        new THREE.Vector3(v1.x, v1.y, v1.z),
                                        new THREE.Vector3(v2.x, v2.y, v2.z)
                                    );
                                    var i = geometry.vertices.length - 3;
                                    geometry.faces.push(new THREE.Face3(i, i+1, i+2));
                                }
                            }
                        }
                        geometry.computeBoundingSphere();
                        geometry.computeFaceNormals();
                        mesh = new THREE.Mesh(geometry, solidMaterial);
                        break;

                    case CANNON.Shape.types.TRIMESH:
                        var geometry = new THREE.Geometry();

                        var v0 = new CANNON.Vec3();
                        var v1 = new CANNON.Vec3();
                        var v2 = new CANNON.Vec3();
                        for (var i = 0; i < shape.indices.length / 3; i++) {
                            shape.getTriangleVertices(i, v0, v1, v2);
                            geometry.vertices.push(
                                new THREE.Vector3(v0.x, v0.y, v0.z),
                                new THREE.Vector3(v1.x, v1.y, v1.z),
                                new THREE.Vector3(v2.x, v2.y, v2.z)
                            );
                            var j = geometry.vertices.length - 3;
                            geometry.faces.push(new THREE.Face3(j, j+1, j+2));
                        }
                        geometry.computeBoundingSphere();
                        geometry.computeFaceNormals();
                        mesh = new THREE.Mesh(geometry, solidMaterial);
                        break;

                    default:
                        throw "Visual type not recognized: "+shape.type;
                    }

                    mesh.receiveShadow = true;
                    mesh.castShadow = true;
                    if(mesh.children){
                        for(var i=0; i<mesh.children.length; i++){
                            mesh.children[i].castShadow = true;
                            mesh.children[i].receiveShadow = true;
                            if(mesh.children[i]){
                                for(var j=0; j<mesh.children[i].length; j++){
                                    mesh.children[i].children[j].castShadow = true;
                                    mesh.children[i].children[j].receiveShadow = true;
                                }
                            }
                        }
                    }

                    var o = body.shapeOffsets[l];
                    var q = body.shapeOrientations[l];
                    mesh.position.set(o.x, o.y, o.z);
                    mesh.quaternion.set(q.x, q.y, q.z, q.w);

                    obj.add(mesh);
                }

                return obj;
            };
            
            // THE SPEED OF IMPACT SHOULD DETERMINE VOLUME
            function playSine(pitch) {
                sine.play(pitch);
            }

        </script>
    </body>
</html>
